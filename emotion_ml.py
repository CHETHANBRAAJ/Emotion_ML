# -*- coding: utf-8 -*-
"""EMotion_ML.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19NyTCI4lBwVqaYNs1v9WYtGJgcdPsGgS
"""

from sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import MultinomialNB
from sklearn import metrics
import pandas as pd

import pandas as pd

# Replace 'your_file.csv' with the actual path to your CSV file
file_path_1 = r'/content/C__Users_CHETHU_Downloads_anger (1).csv'
file_path_2 =r'/content/C__Users_CHETHU_Downloads_fear.csv'
file_path_3=r'/content/C__Users_CHETHU_Downloads_joy.csv'
file_path_4=r'/content/C__Users_CHETHU_Downloads_sad.csv'
file_path_11 = r'/content/C__Users_CHETHU_Downloads_anger2.csv'
file_path_22 =r'/content/C__Users_CHETHU_Downloads_fear2.csv'
file_path_33=r'/content/C__Users_CHETHU_Downloads_joy2.csv'
file_path_44=r'/content/C__Users_CHETHU_Downloads_sad2.csv'

# Specify column names
column_names = ['id', 'text', 'Emotions', 'intensity']  # Add as many column names as needed

# Read CSV file without header
df1 = pd.read_csv(file_path_1, header=None)
df2 = pd.read_csv(file_path_2, header=None)
df3=pd.read_csv(file_path_3, header=None)
df4=pd.read_csv(file_path_4, header=None)
df5 = pd.read_csv(file_path_11, header=None)
df6 = pd.read_csv(file_path_22, header=None)
df7=pd.read_csv(file_path_33, header=None)
df8=pd.read_csv(file_path_44, header=None)


# Assign column names to the DataFrame
df1.columns = column_names
df2.columns = column_names
df3.columns = column_names
df4.columns = column_names
df5.columns = column_names
df6.columns = column_names
df7.columns = column_names
df8.columns = column_names

# Now you have a DataFrame with column names
dff = pd.concat([df1, df2, df3, df4,df5, df6, df7, df8], ignore_index=True)

from sklearn.feature_extraction.text import CountVectorizer
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import MultinomialNB
from sklearn.linear_model import LinearRegression
from sklearn import metrics
import pandas as pd

# Sample dataset with labeled emotions and intensity

df = pd.DataFrame(dff)

# Step 1: Feature Extraction for Emotion
vectorizer = CountVectorizer()
X_emotion = vectorizer.fit_transform(df['text'])
y_emotion = df['Emotions']

# Step 2: Train-test split for Emotion
X_train_emotion, X_test_emotion, y_train_emotion, y_test_emotion = train_test_split(
    X_emotion, y_emotion, test_size=0.2, random_state=42
)

# Train a classifier (Naive Bayes) for Emotion
classifier = MultinomialNB()
classifier.fit(X_train_emotion, y_train_emotion)

# Make predictions for Emotion
y_pred_emotion = classifier.predict(X_test_emotion)

# Feature Extraction for Intensity (using text length as a simple heuristic)
df['text_length'] = df['text'].apply(lambda x: len(x.split()))
X_intensity = df[['text_length']]
y_intensity = df['intensity']

# Train-test split for Intensity
X_train_intensity, X_test_intensity, y_train_intensity, y_test_intensity = train_test_split(
    X_intensity, y_intensity, test_size=0.2, random_state=42
)

# Train a regression model (Linear Regression) for Intensity
regressor = LinearRegression()
regressor.fit(X_train_intensity, y_train_intensity)

# Make predictions for Intensity
y_pred_intensity = regressor.predict(X_test_intensity)

# Step 3: Evaluate the model for Emotion
accuracy_emotion = metrics.accuracy_score(y_test_emotion, y_pred_emotion)
precision_emotion = metrics.precision_score(y_test_emotion, y_pred_emotion, average='weighted')
recall_emotion = metrics.recall_score(y_test_emotion, y_pred_emotion, average='weighted')
f1_score_emotion = metrics.f1_score(y_test_emotion, y_pred_emotion, average='weighted')

# Step 4: Evaluate the model for Intensity
mse_intensity = metrics.mean_squared_error(y_test_intensity, y_pred_intensity)

print(f'Emotion Model Metrics:')
print(f'Accuracy: {accuracy_emotion:.2f}')
print(f'Precision: {precision_emotion:.2f}')
print(f'Recall: {recall_emotion:.2f}')
print(f'F1 Score: {f1_score_emotion:.2f}')

print(f'\nIntensity Model Metrics:')
print(f'Mean Squared Error: {mse_intensity:.2f}')

# Assuming the models and vectorizers are already trained (as shown in the previous code)

# New text to test
new_text = ["Before the year ends I'll probably get master 12s or flu games, true blues, and space jams."]
# Step 1: Transform the new text for emotion using the existing vectorizer
new_text_vectorized_emotion = vectorizer.transform(new_text)

# Step 2: Make predictions for emotion using the trained classifier
new_text_predictions_emotion = classifier.predict(new_text_vectorized_emotion)

# Step 3: Transform the new text for intensity using the existing vectorizer
new_text_vectorized_intensity = vectorizer.transform(new_text)  # Use the same vectorizer for simplicity
new_text_lengths = [len(text.split()) for text in new_text]
new_text_intensity_features = pd.DataFrame({'text_length': new_text_lengths})



# Step 4: Make predictions for intensity using the trained regressor
new_text_predictions_intensity = regressor.predict(new_text_intensity_features)

# Increase intensity values by a fixed factor (e.g., 1.5)
intensity_increase_factor = 1.5
new_text_predictions_intensity_increase = new_text_predictions_intensity * intensity_increase_factor

# Step 5: Display the predictions for emotion and intensity
for text, prediction_emotion, prediction_intensity in zip(new_text, new_text_predictions_emotion, new_text_predictions_intensity_increase):
    print(f'Text: {text}\nPredicted Emotion: {prediction_emotion}\nPredicted Intensity: {prediction_intensity:.2f}\n{"-"*30}')

